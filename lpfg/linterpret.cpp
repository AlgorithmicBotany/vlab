/* ******************************************************************** *
   Copyright (C) 1990-2022 University of Calgary
  
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
  
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.
 * ******************************************************************** */


 
#include <stack>

#include "lengine.h"
#include "comlineparam.h"
#include "drawparam.h"
#include "turtle.h"
#include "glutils.h"
#include "glenv.h"
#include "objout.h"
#include "psout.h"
#include "environment.h"
#include "succstor.h"
#include "file.h"

#include "PerformanceMonitor.h"

void LEngine::CheckNumeric(int vgrp) const {
  // interpret string checking for potential numerical problems
  // if -cn specified at command line
  if (comlineparam.CheckNumeric()) {
    NumericCheckTurtle turtle;
    std::stack<NumericCheckTurtle> Stack;
    InterpretString(turtle, Stack, _lstring, _dll.InterpretationMaxDepth(),
                    _dll.CurrentGroup(), vgrp);
  }
}

namespace Utils {

template <> class PPName<ScreenTurtle> {
public:
  PPName() { glPushName(0); }
  ~PPName() { glPopName(); }
  void Set(size_t id) { glLoadName(static_cast<GLuint>(id)); }
};

template <> class PPName<PixelLineScreenTurtle> {
public:
  PPName() { glPushName(0); }
  ~PPName() { glPopName(); }
  void Set(size_t id) { glLoadName(static_cast<GLuint>(id)); }
};

template <> class PPName<PolygonLineScreenTurtle> {
public:
  PPName() { glPushName(0); }
  ~PPName() { glPopName(); }
  void Set(size_t id) { glLoadName(static_cast<GLuint>(id)); }
};

template <> class PPName<CylinderLineScreenTurtle> {
public:
  PPName() { glPushName(0); }
  ~PPName() { glPopName(); }
  void Set(size_t id) { glLoadName(static_cast<GLuint>(id)); }
};

} // namespace Utils

void LEngine::DrawGL(Vector3d vn, int vgrp, unsigned int glbase,
                     void *pQ) const {
  if (!ValidLsystem())
    return;

  ++_sDrawCount;
  TIME_THIS(3);

  // polygon is used to store
  // and draw polygons
  // generated by SP, PP, EP
  GLDraw::Polygon polygon;

  // different turtle type is used
  // depending on the line style
  switch (drawparams.LineStyle()) {
  case DParams::lsPixel: {
    CheckNumeric(vgrp);
    PixelLineScreenTurtle turtle(glbase, vn, &polygon, pQ);
    std::stack<PixelLineScreenTurtle> Stack;
    InterpretString(turtle, Stack, _lstring, _dll.InterpretationMaxDepth(),
                    _dll.CurrentGroup(), vgrp);
    if (!Stack.empty())
      Utils::Message("Some branches are not terminated\n");
  } break;
  case DParams::lsPolygon: {
    CheckNumeric(vgrp);
    PolygonLineScreenTurtle turtle(glbase, vn, &polygon, pQ);
    std::stack<PolygonLineScreenTurtle> Stack;
    InterpretString(turtle, Stack, _lstring, _dll.InterpretationMaxDepth(),
                    _dll.CurrentGroup(), vgrp);
    if (!Stack.empty())
      Utils::Message("Some branches are not terminated\n");
  } break;
  case DParams::lsCylinder: {
    CheckNumeric(vgrp);
    CylinderLineScreenTurtle turtle(glbase, vn, &polygon, pQ);
    std::stack<CylinderLineScreenTurtle> Stack;
    InterpretString(turtle, Stack, _lstring, _dll.InterpretationMaxDepth(),
                    _dll.CurrentGroup(), vgrp);
    if (!Stack.empty())
      Utils::Message("Some branches are not terminated\n");
  } break;
  }
}

void LEngine::DrawPOVRay(std::ofstream &scene_trg,
                         std::ofstream *surface_trg_arr,
                         std::ofstream &terrain_trg, std::ofstream &layout,
                         int vgrp) const {
  // output to POVray
  POVRayTurtle turtle(scene_trg, surface_trg_arr, layout);

  turtle.terrainDeclaration(terrain_trg);

  std::stack<POVRayTurtle> stack;
  InterpretString(turtle, stack, _lstring, _dll.InterpretationMaxDepth(),
                  _dll.CurrentGroup(), vgrp);
}

void LEngine::DrawRayshade(std::ofstream &target,
                           const Projection &currentProjection, GLEnv &glEnv,
                           std::string fname, int vgrp) const {
  std::string name = fname.substr(0, fname.size() - 4);
  //  Output to Rayshade
  // the following call is necessary otherwise the opengl context is reset
#ifndef WIN32
  _glview[0]->makeCurrent();
#endif // !WIN32
  RayshadeTurtle turtle(target, currentProjection, glEnv, fname);

  turtle.InstanceSurfaces();

  int size[3] = {40, 40, 40};
  turtle.StartNewGrid(size, name);

  std::stack<RayshadeTurtle> stack;
  InterpretString(turtle, stack, _lstring, _dll.InterpretationMaxDepth(),
                  _dll.CurrentGroup(), vgrp);

  turtle.CompleteGrid();

  turtle.Finish(currentProjection, name);
}

void LEngine::InterpretToFile(const std::string &targetFilename) const {
  WriteTextFile targetFile(targetFilename.c_str());
  TextFileTurtle turtle(targetFile.Fp());
  std::stack<TextFileTurtle> stack;

  if (drawparams.IsMultiView()) {
    for (size_t vGroup = 0; drawparams.IsValidViewId(vGroup); ++vGroup) {
      fprintf(targetFile.Fp(), "View: %zu\n", vGroup);
      InterpretString(turtle, stack, _lstring, _dll.InterpretationMaxDepth(),
                      _dll.CurrentGroup(), vGroup);
    }
  } else {
    InterpretString(turtle, stack, _lstring, _dll.InterpretationMaxDepth(),
                    _dll.CurrentGroup(), 0);
  }
}

void LEngine::DrawObj(std::string fname, GLEnv &glEnv, const Volume &v,
                      int vgrp) const {
  // output to obj
  try {
    ObjOutputStore store(fname, glEnv, v);
    ObjTurtle turtle(store);
    std::stack<ObjTurtle> stack;
    InterpretString(turtle, stack, _lstring, _dll.InterpretationMaxDepth(),
                    _dll.CurrentGroup(), vgrp);

  } catch (...) {
    Utils::Error("Error generating Object output\n");
  }
}

void LEngine::DrawPostscript(std::ostream &trg, int vgrp,
                             const Projection &currentProjection,
                             DParams::ProjectionMode mode) const {
  // output to postscript
  Volume vv = CalculateVolume(vgrp).first;
  PsOutputStore store;
  PostscriptTurtle turtle(trg, store, vv, currentProjection, mode);
  std::stack<PostscriptTurtle> stack;
  InterpretString(turtle, stack, _lstring, _dll.InterpretationMaxDepth(),
                  _dll.CurrentGroup(), vgrp);
  turtle.Finish();
}

void LEngine::InterpretForEnvironment(int grp) {
  if (IsESensitive() || _pEnvironment.get() != NULL) {
    TIME_THIS(2);
    ASSERT(ValidLsystem());
    bool IgnoreAnswer = false;
    {
      // Output represents the communication
      // media (file)
      Environment::Output output(_pEnvironment.get());
      EnvironmentTurtle turtle(_lstring,
#ifdef USE_MESH
                               _mesh,
#endif
                               _pEnvironment.get());
      std::stack<EnvironmentTurtle> stack;
      InterpretString(turtle, stack, _lstring, _dll.InterpretationMaxDepth(),
                      grp, 0);

      // if no ?E modules found in the string
      if (!turtle.InterpretedE()) {
        // no need to send anything to the environment
        output.Ignore();
        // or read the answer
        IgnoreAnswer = true;
      } else
        IgnoreAnswer = false;
      if (!stack.empty())
        Utils::Message("Some branches are not terminated\n");
    }
    // if environment present and some queries sent
    if (_pEnvironment.get() != NULL && !IgnoreAnswer) {
      // try to read the answer
      ReadAnswer();
    }
  }
}
